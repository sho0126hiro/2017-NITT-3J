/***  mp1ex02.txt  ***/
/***  s16306  3J43  廣瀬 翔  ***/

1．課題
    short int 型の変数を２進法表現で見たとき，1の個数を数える関数
    int countOnes(short int value)を作りなさい。
    例えばこの関数に10進法表現の10を与えると，2進法表現では1010なので，2を返す。
    例えばこの関数に10進法表現の13を与えると，2進法表現では1101なので，3を返す。
    テストするmainもつくり，十分にテストしてから提出しなさい。どのように考えて十分なテストだと
    考えたのか，考察に書きなさい。また実行結果を貼り付けなさい。
    (mp1ex02.txt）
    
2．使用したプログラム
    #include <3048fone.h>
    #include "h8_3048fone.h"

    int countOnes(short int value){
        short int mask;
        int count;
        while(value!=0){
            if(value&1)count++;
            value=((unsigned short int)value)>>1;
        }
        return count;
    }

    main()
    {
        short int x,y;
        initSCI1(); /*シリアル通信ユニット　SCI-ch1の初期化*/
        SCI1_printf("10進数を2進数に変換し，1の個数を数えます\n"); /*printfと同様*/
        while(1) {/*これは無限ループ*/
            x=SCI1_getInt("数値を入力＞");
            SCI1_printf("二進数で%dは%bです．\n",x,x);
            y=countOnes(x);
            SCI1_printf("1の数は%d個でした．\n",y);
        }
    }
    /*実行結果

    10進数を2進数に変換し，1の個数を数えます
    数値を入力＞3
    二進数で3は11です．
    1の数は2個でした．
    数値を入力＞23
    二進数で23は10111です．
    1の数は4個でした．
    数値を入力＞127
    二進数で127は1111111です．
    1の数は7個でした．
    数値を入力＞1546
    二進数で1546は11000001010です．
    1の数は4個でした．
    数値を入力＞-100
    二進数で-100は1111111110011100です．
    1の数は12個でした．
    
    */
    
3．考察
    十分なテストについて
        「どんな数にも対応できるようにする」ことを目標としてプログラムを作成した。
        小さな数から大きな数、負の数に対応するために、
        while(value!=0)を用いてどんなサイズのデータ（厳密にはshort intの範囲内）に対応できるようにした。
        また、unsigned short int としてvalueを左シフトすることにより、無限ループを防いだ。
        今回は、多数の種類（数の大小、正負）の数を代入し、十分だと判断した。
        
4．まとめ
    「1」との&を取ることによって、0・1の情報は一桁ずつ判断することができる。
    また、左シフトをするときはunsignedをつけると、一番上のbitには0が代入されるため、上書きをされない。
    これらの性質を使用することにより、bit演算について理解を深めることができる。
    この課題もmp1ex01と同様、bit演算についての理解を深め、今回は比較的応用なプログラムのため、応用力を培うためにあると思う。
